// artificial-language/artificial-backend-rust/src/codegen.rs
use artificial_core::IrModule;
use artificial_core::IrStatement;
use artificial_core::IrExpression;

pub struct RustCodegen;

impl RustCodegen {
    pub fn generate(module: &IrModule) -> String {
        let mut code = String::new();

        // Header
        code.push_str("// Generated by ALC\n");
        code.push_str("// DO NOT EDIT\n\n");

        // Main function
        code.push_str("fn main() {\n");

        // Statements
        for stmt in &module.statements {
            Self::generate_statement(&mut code, stmt);
        }

        code.push_str("}\n");

        code
    }

    fn generate_statement(code: &mut String, stmt: &IrStatement) {
        match stmt {
            IrStatement::Accrete(expr) => {
                code.push_str("    println!(");
                Self::generate_expression(code, expr);
                code.push_str(");\n");
            }
        }
    }

    fn generate_expression(code: &mut String, expr: &IrExpression) {
        match expr {
            IrExpression::StringLiteral(s) => {
                let escaped = Self::escape_string(s);
                code.push('"');
                code.push_str(&escaped);
                code.push('"');
            }
        }
    }

    fn escape_string(s: &str) -> String {
        let mut escaped = String::new();
        for ch in s.chars() {
            match ch {
                '"' => escaped.push_str("\\\""),
                '\\' => escaped.push_str("\\\\"),
                '\n' => escaped.push_str("\\n"),
                '\t' => escaped.push_str("\\t"),
                '\r' => escaped.push_str("\\r"),
                _ => escaped.push(ch),
            }
        }
        escaped
    }
}
